{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>\u7b80\u4f53\u4e2d\u6587 | English</p>    SQLAlchemy-Database  <p> SQLAlchemy-Database provides shortcut functions to common database operations for SQLAlchemy ORM. </p> <p> </p>"},{"location":"#introduction","title":"Introduction","text":"<ul> <li>Support <code>SQLAlchemy</code> and <code>SQLModel</code>,recommend using <code>SQLModel</code>.</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install sqlalchemy-database\n</code></pre>"},{"location":"#orm-model","title":"ORM Model","text":""},{"location":"#sqlalchemy-model-sample","title":"SQLAlchemy Model Sample","text":"<pre><code>import datetime\n\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import declarative_base\n\nBase = declarative_base()\n\n\nclass User(Base):\n    __tablename__ = \"User\"\n    id = sa.Column(sa.Integer, primary_key=True)\n    username = sa.Column(sa.String(30), unique=True, index=True, nullable=False)\n    password = sa.Column(sa.String(30), default='')\n    create_time = sa.Column(sa.DateTime, default=datetime.datetime.utcnow)\n</code></pre>"},{"location":"#sqlmodel-model-sample","title":"SQLModel Model Sample","text":"<pre><code>import datetime\n\nfrom sqlmodel import SQLModel, Field\n\n\nclass User(SQLModel, table=True):\n    id: int = Field(default=None, primary_key=True, nullable=False)\n    username: str = Field(title='username', max_length=30, unique=True, index=True, nullable=False)\n    password: str = Field(default='', title='Password')\n    create_time: datetime = Field(default_factory=datetime.now, title='Create Time')\n</code></pre>"},{"location":"#asyncdatabase","title":"AsyncDatabase","text":""},{"location":"#creation-connection","title":"Creation Connection","text":"<pre><code>from sqlalchemy_database import AsyncDatabase\n\n# 1.Create an asynchronous database connection\ndb = AsyncDatabase.create('sqlite+aiosqlite:///amisadmin.db?check_same_thread=False')  # sqlite\n# db = AsyncDatabase.create('mysql+aiomysql://root:123456@127.0.0.1:3306/amisadmin?charset=utf8mb4')# mysql\n# db = AsyncDatabase.create('postgresql+asyncpg://postgres:root@127.0.0.1:5432/amisadmin')# postgresql\n</code></pre>"},{"location":"#database","title":"Database","text":""},{"location":"#creation-connection_1","title":"Creation Connection","text":"<pre><code>from sqlalchemy_database import Database\n\n# 1.Create a database connection\ndb = Database.create('sqlite:///amisadmin.db?check_same_thread=False')  # sqlite\n# db = Database.create('mysql+pymysql://root:123456@127.0.0.1:3306/amisadmin?charset=utf8mb4') # mysql\n# db = Database.create('postgresql://postgres:root@127.0.0.1:5432/amisadmin') # postgresql\n# db = Database.create('oracle+cx_oracle://scott:tiger@tnsname') # oracle\n# db = Database.create('mssql+pyodbc://scott:tiger@mydsn') # SQL Server\n</code></pre>"},{"location":"#abcasyncdatabase","title":"AbcAsyncDatabase","text":"<p>When you are developing a library of tools, your Python program may require a database connection.</p> <p>But you can't be sure whether the other person personally prefers synchronous or asynchronous connections.</p> <p>You can use asynchronous shortcut functions with the <code>async_</code> prefix.</p> <p><code>AsyncDatabase</code> and <code>Database</code> both inherit from <code>AbcAsyncDatabase</code> and both implement the usual <code>async_</code> prefixed asynchronous shortcut functions.</p> <p>For example: <code>async_execute</code>,<code>async_scalar</code>,<code>async_scalars</code>,<code>async_get</code>,<code>async_delete</code>,<code>async_run_sync</code>.</p> <p>Remark: The <code>async_</code> prefix in <code>Database</code> is implemented by executing the corresponding synchronous shortcut in the thread pool.</p>"},{"location":"#asynchronous-compatible-shortcut-functions","title":"Asynchronous compatible shortcut functions","text":"<pre><code>from sqlalchemy import insert, select, update, delete\nfrom sqlalchemy_database import AsyncDatabase, Database\n\n\nasync def fast_execute(db: Union[AsyncDatabase, Database]):\n    # update\n    stmt = update(User).where(User.id == 1).values({'username': 'new_user'})\n    result = await db.async_execute(stmt)\n\n    # select\n    stmt = select(User).where(User.id == 1)\n    user = await db.async_execute(stmt, on_close_pre=lambda r: r.scalar())\n\n    # insert\n    stmt = insert(User).values({'username': 'User-6', 'password': 'password-6'})\n    result = await db.async_execute(stmt)\n\n    # delete\n    stmt = delete(User).where(User.id == 6)\n    result = await db.async_execute(stmt)\n\n    # scalar\n    user = await db.async_scalar(select(User).where(User.id == 1))\n\n    # scalars\n    stmt = select(User)\n    result = await db.async_scalars(stmt)\n\n    # get\n    user = await db.async_get(User, 1)\n\n    # delete\n    user = User(id=1, name='test')\n    await db.async_delete(user)\n\n    # run_sync\n    await db.async_run_sync(Base.metadata.create_all, is_session=False)\n</code></pre>"},{"location":"#use-dependencies-in-fastapi","title":"Use dependencies in FastAPI","text":"<pre><code>app = FastAPI()\n\n\n# AsyncDatabase\n@app.get(\"/user/{id}\")\nasync def get_user(id: int, session: AsyncSession = Depends(db.session_generator)):\n    return await session.get(User, id)\n\n\n# Database\n@app.get(\"/user/{id}\")\ndef get_user(id: int, session: Session = Depends(db.session_generator)):\n    return session.get(User, id)\n</code></pre>"},{"location":"#use-middleware-in-fastapi","title":"Use middleware in FastAPI","text":"<pre><code>app = FastAPI()\n\n# Database\nsync_db = Database.create(\"sqlite:///amisadmin.db?check_same_thread=False\")\n\napp.add_middleware(sync_db.asgi_middleware)\n\n\n@app.get(\"/user/{id}\")\ndef get_user(id: int):\n    return sync_db.session.get(User, id)\n\n\n# AsyncDatabase\nasync_db = AsyncDatabase.create(\"sqlite+aiosqlite:///amisadmin.db?check_same_thread=False\")\n\napp.add_middleware(async_db.asgi_middleware)\n\n\n@app.get(\"/user/{id}\")\nasync def get_user(id: int):\n    return await async_db.session.get(User, id)\n</code></pre>"},{"location":"#get-session-object","title":"Get session object","text":"<p>You can get the session object anywhere, but you need to manage the lifecycle of the session yourself. For example:</p> <ul> <li> <p>1.In FastAPI, you can use middleware or dependencies to get the session object. In the routing function, the method called will   automatically get the session object in the context.</p> </li> <li> <p>2.In the local work unit, you can use the <code>with</code> statement to get the session object. In the <code>with</code> statement, the method called   will automatically get a new session object.</p> </li> </ul> graph LR session[Get session] --&gt; scopefunc{Read context var} scopefunc --&gt;|None| gSession[Return the global default session] scopefunc --&gt;|Not a Session object| sSession[Return the scoped session corresponding to the current context variable] scopefunc --&gt;|Is a Session object| cSession[Return session in the current context variable]"},{"location":"#more-tutorial-documentation","title":"More tutorial documentation","text":""},{"location":"#sqlalchemy","title":"sqlalchemy","text":"<p><code>SQLAlchemy-Database</code> adds extension functionality to <code>SQLAlchemy</code>.</p> <p>More features and complicated to use, please refer to the <code>SQLAlchemy</code> documentation.</p> <p><code>SQLAlchemy</code> is very powerful and can fulfill almost any complex need you have.</p>"},{"location":"#sqlmodel","title":"sqlmodel","text":"<p>Recommend you to use <code>SQLModel</code> definition <code>ORM</code> model, please refer to the <code>SQLModel</code> documentation.</p> <p><code>SQLModel</code>  written by <code>FastAPI</code> author, Perfectly combine SQLAlchemy with Pydantic, and have all their features .</p>"},{"location":"#relevant-project","title":"Relevant project","text":"<ul> <li>FastAPI-Amis-Admin</li> </ul>"},{"location":"#license","title":"License","text":"<p>According to the <code>Apache2.0</code> protocol.</p>"},{"location":"mkdocstring/","title":"Reference","text":"<p>             Bases: <code>AbcAsyncDatabase</code></p> <p><code>sqlalchemy</code> asynchronous database client</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>class AsyncDatabase(AbcAsyncDatabase):\n\"\"\"`sqlalchemy` asynchronous database client\"\"\"\n\n    def __init__(\n        self,\n        engine: AsyncEngine,\n        commit_on_exit: bool = True,\n        **session_options,\n    ):\n\"\"\"\n        Initialize the client through the asynchronous engine\n        Args:\n            engine: Asynchronous Engine\n            commit_on_exit: Whether to commit the session when the context manager or session generator exits.\n            **session_options: The default `session` initialization parameters\n        \"\"\"\n        self.engine: AsyncEngine = engine\n\"\"\"`sqlalchemy` Asynchronous Engine\n\n        Example:\n            ```Python\n            async with self.engine.begin() as conn:\n                await conn.run_sync(SQLModel.metadata.create_all)\n            ```\n        \"\"\"\n        self.commit_on_exit: bool = commit_on_exit\n\"\"\"Whether to commit the session when the context manager or session generator exits.\"\"\"\n        session_options.setdefault(\"class_\", AsyncSession)\n        self.session_maker: Callable[..., AsyncSession] = sessionmaker(self.engine, **session_options)\n\"\"\"`sqlalchemy` session factory function\n\n        Example:\n            ```Python\n            async with self.session_maker() as sesson:\n                await session.delete(User,1)\n                await session.commit()\n            ```\n        \"\"\"\n        self._session_scope: ContextVar[Union[str, AsyncSession, None]] = ContextVar(\n            f\"_session_context_var_{id(self)}\", default=None\n        )\n        self.scoped_session: async_scoped_session = async_scoped_session(self.session_maker, scopefunc=self._session_scope.get)\n        super().__init__(engine)\n\n    @property\n    def session(self) -&gt; AsyncSession:\n\"\"\"Return an instance of Session local to the current async context.\n\n        Note: Must register middleware in fastapi application to get session in request.\n\n        Example:\n            ```Python\n            app = FastAPI()\n            app.add_middleware(db.asgi_middleware)\n\n            @app.get('/get_user')\n            async def get_user(id:int):\n                return await db.session.get(User,id)\n            ```\n        In ordinary methods, session will return None. You can get it through:\n            ```Python\n            async with db():\n                await db.session.get(User,id)\n            ```\n        \"\"\"\n        return self.scoped_session()\n\n    @property\n    def scoped(self) -&gt; bool:\n\"\"\"Whether the current context has a session. If False, the session is the default global session,\n        and the transaction needs to be manually submitted.\n        \"\"\"\n        return bool(self._session_scope.get())\n\n    def __call__(self, scope: Any = None):\n        return AsyncSessionContextVarManager(self, scope=scope)\n\n    @classmethod\n    def create(\n        cls, url: Union[str, URL], *, commit_on_exit: bool = True, session_options: Mapping[str, Any] = None, **kwargs\n    ) -&gt; \"AsyncDatabase\":\n\"\"\"\n        Initialize the client with a database connection string\n        Args:\n            url: Asynchronous database connection string\n            commit_on_exit: Whether to commit the session when the context manager or session generator exits.\n            session_options: The default `session` initialization parameters\n            **kwargs: Asynchronous engine initialization parameters\n\n        Returns:\n            Return the client instance.\n        \"\"\"\n        kwargs.setdefault(\"future\", True)\n        engine = create_async_engine(url, **kwargs)\n        session_options = session_options or {}\n        return cls(engine, commit_on_exit=commit_on_exit, **session_options)\n\n    async def session_generator(self) -&gt; AsyncGenerator[AsyncSession, Any]:\n\"\"\"AsyncSession Generator, available for FastAPI dependencies.\n\n        Example:\n            ```Python\n            @router.get('/get_user')\n            async get_user(id:int,session:AsyncSession=Depends(db.session_generator)):\n                return await session.get(User,id)\n            ```\n        \"\"\"\n        if self.scoped:\n\"\"\"If the current context has a session, return it.\"\"\"\n            yield self.session\n        else:\n\"\"\"If the current context has no session, create a new session.\"\"\"\n            async with self.session_maker() as session:\n                yield session\n                if self.commit_on_exit:\n                    await session.commit()\n\n    async def run_sync(\n        self,\n        fn: Callable[[Concatenate[Union[Session, Connection], _P]], _T],\n        *args: _P.args,\n        is_session: bool = True,\n        **kwargs: _P.kwargs,\n    ) -&gt; Union[_T, _R]:\n\"\"\"\n        Invoke the given sync callable passing sync self as the first\n        argument.\n\n        This method maintains the asyncio event loop all the way through\n        to the database connection by running the given callable in a\n        specially instrumented greenlet.\n\n        Args:\n            fn: Synchronization function\n            *args: Synchronization function positional argument\n            is_session: Session or not. If true, an `AsyncSession` is created.\n                If false, an `AsyncConnection` is created. The default is true.\n            **kwargs: Synchronization function keyword argument\n\n        Returns: Returns the result of the fn synchronization function.\n\n        Example:\n            ```Python\n            def get_user(session:Session,id:int):\n                return session.get(User,id)\n\n            user = await db.run_sync(get_user,5)\n            ```\n        None:\n            The provided callable is invoked inline within the asyncio event\n            loop, and will block on traditional IO calls.  IO within this\n            callable should only call into SQLAlchemy's asyncio database\n            APIs which will be properly adapted to the greenlet context.\n        \"\"\"\n        if is_session:\n            return await self.session.run_sync(fn, *args, **kwargs)\n        async with self.engine.begin() as conn:\n            return await conn.run_sync(fn, *args, **kwargs)\n</code></pre>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.commit_on_exit","title":"<code>commit_on_exit: bool = commit_on_exit</code>  <code>instance-attribute</code>","text":"<p>Whether to commit the session when the context manager or session generator exits.</p>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.engine","title":"<code>engine: AsyncEngine = engine</code>  <code>instance-attribute</code>","text":"<p><code>sqlalchemy</code> Asynchronous Engine</p> Example <pre><code>async with self.engine.begin() as conn:\n    await conn.run_sync(SQLModel.metadata.create_all)\n</code></pre>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.scoped","title":"<code>scoped: bool</code>  <code>property</code>","text":"<p>Whether the current context has a session. If False, the session is the default global session, and the transaction needs to be manually submitted.</p>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.session","title":"<code>session: AsyncSession</code>  <code>property</code>","text":"<p>Return an instance of Session local to the current async context.</p> <p>Note: Must register middleware in fastapi application to get session in request.</p> Example <pre><code>app = FastAPI()\napp.add_middleware(db.asgi_middleware)\n\n@app.get('/get_user')\nasync def get_user(id:int):\n    return await db.session.get(User,id)\n</code></pre> <p>In ordinary methods, session will return None. You can get it through:     <pre><code>async with db():\n    await db.session.get(User,id)\n</code></pre></p>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.session_maker","title":"<code>session_maker: Callable[..., AsyncSession] = sessionmaker(self.engine, **session_options)</code>  <code>instance-attribute</code>","text":"<p><code>sqlalchemy</code> session factory function</p> Example <pre><code>async with self.session_maker() as sesson:\n    await session.delete(User,1)\n    await session.commit()\n</code></pre>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.__init__","title":"<code>__init__(engine, commit_on_exit=True, **session_options)</code>","text":"<p>Initialize the client through the asynchronous engine Args:     engine: Asynchronous Engine     commit_on_exit: Whether to commit the session when the context manager or session generator exits.     **session_options: The default <code>session</code> initialization parameters</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>def __init__(\n    self,\n    engine: AsyncEngine,\n    commit_on_exit: bool = True,\n    **session_options,\n):\n\"\"\"\n    Initialize the client through the asynchronous engine\n    Args:\n        engine: Asynchronous Engine\n        commit_on_exit: Whether to commit the session when the context manager or session generator exits.\n        **session_options: The default `session` initialization parameters\n    \"\"\"\n    self.engine: AsyncEngine = engine\n\"\"\"`sqlalchemy` Asynchronous Engine\n\n    Example:\n        ```Python\n        async with self.engine.begin() as conn:\n            await conn.run_sync(SQLModel.metadata.create_all)\n        ```\n    \"\"\"\n    self.commit_on_exit: bool = commit_on_exit\n\"\"\"Whether to commit the session when the context manager or session generator exits.\"\"\"\n    session_options.setdefault(\"class_\", AsyncSession)\n    self.session_maker: Callable[..., AsyncSession] = sessionmaker(self.engine, **session_options)\n\"\"\"`sqlalchemy` session factory function\n\n    Example:\n        ```Python\n        async with self.session_maker() as sesson:\n            await session.delete(User,1)\n            await session.commit()\n        ```\n    \"\"\"\n    self._session_scope: ContextVar[Union[str, AsyncSession, None]] = ContextVar(\n        f\"_session_context_var_{id(self)}\", default=None\n    )\n    self.scoped_session: async_scoped_session = async_scoped_session(self.session_maker, scopefunc=self._session_scope.get)\n    super().__init__(engine)\n</code></pre>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.create","title":"<code>create(url, *, commit_on_exit=True, session_options=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize the client with a database connection string Args:     url: Asynchronous database connection string     commit_on_exit: Whether to commit the session when the context manager or session generator exits.     session_options: The default <code>session</code> initialization parameters     **kwargs: Asynchronous engine initialization parameters</p> <p>Returns:</p> Type Description <code>AsyncDatabase</code> <p>Return the client instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>@classmethod\ndef create(\n    cls, url: Union[str, URL], *, commit_on_exit: bool = True, session_options: Mapping[str, Any] = None, **kwargs\n) -&gt; \"AsyncDatabase\":\n\"\"\"\n    Initialize the client with a database connection string\n    Args:\n        url: Asynchronous database connection string\n        commit_on_exit: Whether to commit the session when the context manager or session generator exits.\n        session_options: The default `session` initialization parameters\n        **kwargs: Asynchronous engine initialization parameters\n\n    Returns:\n        Return the client instance.\n    \"\"\"\n    kwargs.setdefault(\"future\", True)\n    engine = create_async_engine(url, **kwargs)\n    session_options = session_options or {}\n    return cls(engine, commit_on_exit=commit_on_exit, **session_options)\n</code></pre>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.run_sync","title":"<code>run_sync(fn, *args, is_session=True, **kwargs)</code>  <code>async</code>","text":"<p>Invoke the given sync callable passing sync self as the first argument.</p> <p>This method maintains the asyncio event loop all the way through to the database connection by running the given callable in a specially instrumented greenlet.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[Concatenate[Union[Session, Connection], _P]], _T]</code> <p>Synchronization function</p> required <code>*args</code> <code>args</code> <p>Synchronization function positional argument</p> <code>()</code> <code>is_session</code> <code>bool</code> <p>Session or not. If true, an <code>AsyncSession</code> is created. If false, an <code>AsyncConnection</code> is created. The default is true.</p> <code>True</code> <code>**kwargs</code> <code>kwargs</code> <p>Synchronization function keyword argument</p> <code>{}</code> Example <pre><code>def get_user(session:Session,id:int):\n    return session.get(User,id)\n\nuser = await db.run_sync(get_user,5)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>async def run_sync(\n    self,\n    fn: Callable[[Concatenate[Union[Session, Connection], _P]], _T],\n    *args: _P.args,\n    is_session: bool = True,\n    **kwargs: _P.kwargs,\n) -&gt; Union[_T, _R]:\n\"\"\"\n    Invoke the given sync callable passing sync self as the first\n    argument.\n\n    This method maintains the asyncio event loop all the way through\n    to the database connection by running the given callable in a\n    specially instrumented greenlet.\n\n    Args:\n        fn: Synchronization function\n        *args: Synchronization function positional argument\n        is_session: Session or not. If true, an `AsyncSession` is created.\n            If false, an `AsyncConnection` is created. The default is true.\n        **kwargs: Synchronization function keyword argument\n\n    Returns: Returns the result of the fn synchronization function.\n\n    Example:\n        ```Python\n        def get_user(session:Session,id:int):\n            return session.get(User,id)\n\n        user = await db.run_sync(get_user,5)\n        ```\n    None:\n        The provided callable is invoked inline within the asyncio event\n        loop, and will block on traditional IO calls.  IO within this\n        callable should only call into SQLAlchemy's asyncio database\n        APIs which will be properly adapted to the greenlet context.\n    \"\"\"\n    if is_session:\n        return await self.session.run_sync(fn, *args, **kwargs)\n    async with self.engine.begin() as conn:\n        return await conn.run_sync(fn, *args, **kwargs)\n</code></pre>"},{"location":"mkdocstring/#sqlalchemy_database.database.AsyncDatabase.session_generator","title":"<code>session_generator()</code>  <code>async</code>","text":"<p>AsyncSession Generator, available for FastAPI dependencies.</p> Example <pre><code>@router.get('/get_user')\nasync get_user(id:int,session:AsyncSession=Depends(db.session_generator)):\n    return await session.get(User,id)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>async def session_generator(self) -&gt; AsyncGenerator[AsyncSession, Any]:\n\"\"\"AsyncSession Generator, available for FastAPI dependencies.\n\n    Example:\n        ```Python\n        @router.get('/get_user')\n        async get_user(id:int,session:AsyncSession=Depends(db.session_generator)):\n            return await session.get(User,id)\n        ```\n    \"\"\"\n    if self.scoped:\n\"\"\"If the current context has a session, return it.\"\"\"\n        yield self.session\n    else:\n\"\"\"If the current context has no session, create a new session.\"\"\"\n        async with self.session_maker() as session:\n            yield session\n            if self.commit_on_exit:\n                await session.commit()\n</code></pre>"},{"location":"Reference/AbcAsyncDatabase/","title":"AbcAsyncDatabase","text":"<p><code>sqlalchemy</code> asynchronous database abstract base class, not directly instantiated</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/_abc_async_database.py</code> <pre><code>class AbcAsyncDatabase(metaclass=abc.ABCMeta):  # noqa: B024\n\n    _instances: Dict[str, \"AbcAsyncDatabase\"] = None\n\n    def __new__(cls, engine: Union[Engine, AsyncEngine], *args, **kwargs):\n\"\"\"Create a new instance of the database class.Each engine url corresponds to a database instance,\n        and if it already exists, it is directly returned, otherwise a new instance is created.\n        \"\"\"\n        cls._instances = cls._instances or {}\n        if engine.url not in cls._instances:\n            cls._instances[engine.url] = super().__new__(cls)\n        return cls._instances[engine.url]\n\n    def __init__(self, engine: Union[Engine, AsyncEngine], *args, **kwargs) -&gt; None:\n        for func_name in {\n            \"run_sync\",\n            \"begin\",\n            \"begin_nested\",\n            \"close\",\n            \"commit\",\n            \"connection\",\n            \"delete\",\n            \"execute\",\n            \"flush\",\n            \"get\",\n            \"merge\",\n            \"refresh\",\n            \"rollback\",\n            \"scalar\",\n            \"scalars\",\n            \"add\",\n            \"add_all\",\n            \"expire\",\n            \"expire_all\",\n            \"expunge\",\n            \"expunge_all\",\n            \"get_bind\",\n            \"is_modified\",\n        }:\n            func = getattr(self, func_name, None)\n            if not func:\n                func = getattr(self.scoped_session, func_name)  # type: ignore\n                setattr(self, func_name, func)\n\"\"\"Create a proxy method for the scoped_session method.Note that this method is not recommended,\n                because it will cause the type of db.session to be unclear, which is not conducive to the code prompt of IDE.\"\"\"\n            if func_name in {\n                \"add\",\n                \"add_all\",\n                \"expire\",\n                \"expire_all\",\n                \"expunge\",\n                \"expunge_all\",\n                \"get_bind\",\n                \"is_modified\",\n            }:  # These methods do not need to be asynchronous.\n                continue\n            if not asyncio.iscoroutinefunction(func) and isinstance(self.scoped_session, scoped_session):  # type: ignore\n                func = functools.partial(to_thread, func)\n            setattr(self, f\"async_{func_name}\", func)\n\n    async def asgi_dispatch(self, request, call_next):\n\"\"\"\n        This method has been deprecated and is not recommended. Please use the `asgi_middleware` method instead.\n        Reference: https://www.starlette.io/middleware/#limitations\n        \"\"\"\n        # \u6253\u5370\u8b66\u544a\u4fe1\u606f\n        warnings.warn(\n            \"This method has been deprecated and is not recommended. Please use the `asgi_middleware` method instead.\",\n            DeprecationWarning,\n        )\n        if request.scope.get(f\"__sqlalchemy_database__:{id(self)}\", False):\n            return await call_next(request)\n        # bind session to request\n        async with self.__call__(scope=id(request.scope)):\n            request.scope[f\"__sqlalchemy_database__:{id(self)}\"] = self\n            return await call_next(request)\n\n    def attach_middleware(self, app):\n\"\"\"Attach the middleware to the ASGI application.\n        Example:\n            ```Python\n            app = FastAPI()\n            db = Database.create(\"sqlite:///test.db\")\n            db.attach_middlewares(app)\n            ```\n        \"\"\"\n        app.add_middleware(self.asgi_middleware)\n\n    @property\n    def asgi_middleware(self):\n\"\"\"Middleware for ASGI applications, such as: Starlette, FastAPI, Quart, Sanic, Hug, Responder, etc.\n        Bind a SQLAlchemy session connection to the incoming HTTP request session context,\n        you can access the session object through `self.session`.\n        The instance shortcut method will also try to use this `session` object by default.\n        Example:\n            ```Python\n            app = FastAPI()\n            db = Database.create(\"sqlite:///test.db\")\n            app.add_middleware(db.asgi_middleware)\n            ```\n        \"\"\"\n\n        def asgi_decorator(app):\n            @functools.wraps(app)\n            async def wrapped_app(scope, receive, send):\n                if scope.get(f\"__sqlalchemy_database__:{id(self)}\", False):\n                    return await app(scope, receive, send)\n                    # bind session to request\n                async with self.__call__(scope=id(scope)):\n                    scope[f\"__sqlalchemy_database__:{id(self)}\"] = self\n                    await app(scope, receive, send)\n\n            return wrapped_app\n\n        return asgi_decorator\n</code></pre>"},{"location":"Reference/AbcAsyncDatabase/#sqlalchemy_database._abc_async_database.AbcAsyncDatabase.asgi_middleware","title":"<code>asgi_middleware</code>  <code>property</code>","text":"<p>Middleware for ASGI applications, such as: Starlette, FastAPI, Quart, Sanic, Hug, Responder, etc. Bind a SQLAlchemy session connection to the incoming HTTP request session context, you can access the session object through <code>self.session</code>. The instance shortcut method will also try to use this <code>session</code> object by default. Example:     <pre><code>app = FastAPI()\ndb = Database.create(\"sqlite:///test.db\")\napp.add_middleware(db.asgi_middleware)\n</code></pre></p>"},{"location":"Reference/AbcAsyncDatabase/#sqlalchemy_database._abc_async_database.AbcAsyncDatabase.__new__","title":"<code>__new__(engine, *args, **kwargs)</code>","text":"<p>Create a new instance of the database class.Each engine url corresponds to a database instance, and if it already exists, it is directly returned, otherwise a new instance is created.</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/_abc_async_database.py</code> <pre><code>def __new__(cls, engine: Union[Engine, AsyncEngine], *args, **kwargs):\n\"\"\"Create a new instance of the database class.Each engine url corresponds to a database instance,\n    and if it already exists, it is directly returned, otherwise a new instance is created.\n    \"\"\"\n    cls._instances = cls._instances or {}\n    if engine.url not in cls._instances:\n        cls._instances[engine.url] = super().__new__(cls)\n    return cls._instances[engine.url]\n</code></pre>"},{"location":"Reference/AbcAsyncDatabase/#sqlalchemy_database._abc_async_database.AbcAsyncDatabase.asgi_dispatch","title":"<code>asgi_dispatch(request, call_next)</code>  <code>async</code>","text":"<p>This method has been deprecated and is not recommended. Please use the <code>asgi_middleware</code> method instead. Reference: https://www.starlette.io/middleware/#limitations</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/_abc_async_database.py</code> <pre><code>async def asgi_dispatch(self, request, call_next):\n\"\"\"\n    This method has been deprecated and is not recommended. Please use the `asgi_middleware` method instead.\n    Reference: https://www.starlette.io/middleware/#limitations\n    \"\"\"\n    # \u6253\u5370\u8b66\u544a\u4fe1\u606f\n    warnings.warn(\n        \"This method has been deprecated and is not recommended. Please use the `asgi_middleware` method instead.\",\n        DeprecationWarning,\n    )\n    if request.scope.get(f\"__sqlalchemy_database__:{id(self)}\", False):\n        return await call_next(request)\n    # bind session to request\n    async with self.__call__(scope=id(request.scope)):\n        request.scope[f\"__sqlalchemy_database__:{id(self)}\"] = self\n        return await call_next(request)\n</code></pre>"},{"location":"Reference/AbcAsyncDatabase/#sqlalchemy_database._abc_async_database.AbcAsyncDatabase.attach_middleware","title":"<code>attach_middleware(app)</code>","text":"<p>Attach the middleware to the ASGI application. Example:     <pre><code>app = FastAPI()\ndb = Database.create(\"sqlite:///test.db\")\ndb.attach_middlewares(app)\n</code></pre></p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/_abc_async_database.py</code> <pre><code>def attach_middleware(self, app):\n\"\"\"Attach the middleware to the ASGI application.\n    Example:\n        ```Python\n        app = FastAPI()\n        db = Database.create(\"sqlite:///test.db\")\n        db.attach_middlewares(app)\n        ```\n    \"\"\"\n    app.add_middleware(self.asgi_middleware)\n</code></pre>"},{"location":"Reference/AsyncDatabase/","title":"AsyncDatabase","text":"<p>             Bases: <code>AbcAsyncDatabase</code></p> <p><code>sqlalchemy</code> asynchronous database client</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>class AsyncDatabase(AbcAsyncDatabase):\n\"\"\"`sqlalchemy` asynchronous database client\"\"\"\n\n    def __init__(\n        self,\n        engine: AsyncEngine,\n        commit_on_exit: bool = True,\n        **session_options,\n    ):\n\"\"\"\n        Initialize the client through the asynchronous engine\n        Args:\n            engine: Asynchronous Engine\n            commit_on_exit: Whether to commit the session when the context manager or session generator exits.\n            **session_options: The default `session` initialization parameters\n        \"\"\"\n        self.engine: AsyncEngine = engine\n\"\"\"`sqlalchemy` Asynchronous Engine\n\n        Example:\n            ```Python\n            async with self.engine.begin() as conn:\n                await conn.run_sync(SQLModel.metadata.create_all)\n            ```\n        \"\"\"\n        self.commit_on_exit: bool = commit_on_exit\n\"\"\"Whether to commit the session when the context manager or session generator exits.\"\"\"\n        session_options.setdefault(\"class_\", AsyncSession)\n        self.session_maker: Callable[..., AsyncSession] = sessionmaker(self.engine, **session_options)\n\"\"\"`sqlalchemy` session factory function\n\n        Example:\n            ```Python\n            async with self.session_maker() as sesson:\n                await session.delete(User,1)\n                await session.commit()\n            ```\n        \"\"\"\n        self._session_scope: ContextVar[Union[str, AsyncSession, None]] = ContextVar(\n            f\"_session_context_var_{id(self)}\", default=None\n        )\n        self.scoped_session: async_scoped_session = async_scoped_session(self.session_maker, scopefunc=self._session_scope.get)\n        super().__init__(engine)\n\n    @property\n    def session(self) -&gt; AsyncSession:\n\"\"\"Return an instance of Session local to the current async context.\n\n        Note: Must register middleware in fastapi application to get session in request.\n\n        Example:\n            ```Python\n            app = FastAPI()\n            app.add_middleware(db.asgi_middleware)\n\n            @app.get('/get_user')\n            async def get_user(id:int):\n                return await db.session.get(User,id)\n            ```\n        In ordinary methods, session will return None. You can get it through:\n            ```Python\n            async with db():\n                await db.session.get(User,id)\n            ```\n        \"\"\"\n        return self.scoped_session()\n\n    @property\n    def scoped(self) -&gt; bool:\n\"\"\"Whether the current context has a session. If False, the session is the default global session,\n        and the transaction needs to be manually submitted.\n        \"\"\"\n        return bool(self._session_scope.get())\n\n    def __call__(self, scope: Any = None):\n        return AsyncSessionContextVarManager(self, scope=scope)\n\n    @classmethod\n    def create(\n        cls, url: Union[str, URL], *, commit_on_exit: bool = True, session_options: Mapping[str, Any] = None, **kwargs\n    ) -&gt; \"AsyncDatabase\":\n\"\"\"\n        Initialize the client with a database connection string\n        Args:\n            url: Asynchronous database connection string\n            commit_on_exit: Whether to commit the session when the context manager or session generator exits.\n            session_options: The default `session` initialization parameters\n            **kwargs: Asynchronous engine initialization parameters\n\n        Returns:\n            Return the client instance.\n        \"\"\"\n        kwargs.setdefault(\"future\", True)\n        engine = create_async_engine(url, **kwargs)\n        session_options = session_options or {}\n        return cls(engine, commit_on_exit=commit_on_exit, **session_options)\n\n    async def session_generator(self) -&gt; AsyncGenerator[AsyncSession, Any]:\n\"\"\"AsyncSession Generator, available for FastAPI dependencies.\n\n        Example:\n            ```Python\n            @router.get('/get_user')\n            async get_user(id:int,session:AsyncSession=Depends(db.session_generator)):\n                return await session.get(User,id)\n            ```\n        \"\"\"\n        if self.scoped:\n\"\"\"If the current context has a session, return it.\"\"\"\n            yield self.session\n        else:\n\"\"\"If the current context has no session, create a new session.\"\"\"\n            async with self.session_maker() as session:\n                yield session\n                if self.commit_on_exit:\n                    await session.commit()\n\n    async def run_sync(\n        self,\n        fn: Callable[[Concatenate[Union[Session, Connection], _P]], _T],\n        *args: _P.args,\n        is_session: bool = True,\n        **kwargs: _P.kwargs,\n    ) -&gt; Union[_T, _R]:\n\"\"\"\n        Invoke the given sync callable passing sync self as the first\n        argument.\n\n        This method maintains the asyncio event loop all the way through\n        to the database connection by running the given callable in a\n        specially instrumented greenlet.\n\n        Args:\n            fn: Synchronization function\n            *args: Synchronization function positional argument\n            is_session: Session or not. If true, an `AsyncSession` is created.\n                If false, an `AsyncConnection` is created. The default is true.\n            **kwargs: Synchronization function keyword argument\n\n        Returns: Returns the result of the fn synchronization function.\n\n        Example:\n            ```Python\n            def get_user(session:Session,id:int):\n                return session.get(User,id)\n\n            user = await db.run_sync(get_user,5)\n            ```\n        None:\n            The provided callable is invoked inline within the asyncio event\n            loop, and will block on traditional IO calls.  IO within this\n            callable should only call into SQLAlchemy's asyncio database\n            APIs which will be properly adapted to the greenlet context.\n        \"\"\"\n        if is_session:\n            return await self.session.run_sync(fn, *args, **kwargs)\n        async with self.engine.begin() as conn:\n            return await conn.run_sync(fn, *args, **kwargs)\n</code></pre>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.commit_on_exit","title":"<code>commit_on_exit: bool = commit_on_exit</code>  <code>instance-attribute</code>","text":"<p>Whether to commit the session when the context manager or session generator exits.</p>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.engine","title":"<code>engine: AsyncEngine = engine</code>  <code>instance-attribute</code>","text":"<p><code>sqlalchemy</code> Asynchronous Engine</p> Example <pre><code>async with self.engine.begin() as conn:\n    await conn.run_sync(SQLModel.metadata.create_all)\n</code></pre>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.scoped","title":"<code>scoped: bool</code>  <code>property</code>","text":"<p>Whether the current context has a session. If False, the session is the default global session, and the transaction needs to be manually submitted.</p>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.session","title":"<code>session: AsyncSession</code>  <code>property</code>","text":"<p>Return an instance of Session local to the current async context.</p> <p>Note: Must register middleware in fastapi application to get session in request.</p> Example <pre><code>app = FastAPI()\napp.add_middleware(db.asgi_middleware)\n\n@app.get('/get_user')\nasync def get_user(id:int):\n    return await db.session.get(User,id)\n</code></pre> <p>In ordinary methods, session will return None. You can get it through:     <pre><code>async with db():\n    await db.session.get(User,id)\n</code></pre></p>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.session_maker","title":"<code>session_maker: Callable[..., AsyncSession] = sessionmaker(self.engine, **session_options)</code>  <code>instance-attribute</code>","text":"<p><code>sqlalchemy</code> session factory function</p> Example <pre><code>async with self.session_maker() as sesson:\n    await session.delete(User,1)\n    await session.commit()\n</code></pre>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.__init__","title":"<code>__init__(engine, commit_on_exit=True, **session_options)</code>","text":"<p>Initialize the client through the asynchronous engine Args:     engine: Asynchronous Engine     commit_on_exit: Whether to commit the session when the context manager or session generator exits.     **session_options: The default <code>session</code> initialization parameters</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>def __init__(\n    self,\n    engine: AsyncEngine,\n    commit_on_exit: bool = True,\n    **session_options,\n):\n\"\"\"\n    Initialize the client through the asynchronous engine\n    Args:\n        engine: Asynchronous Engine\n        commit_on_exit: Whether to commit the session when the context manager or session generator exits.\n        **session_options: The default `session` initialization parameters\n    \"\"\"\n    self.engine: AsyncEngine = engine\n\"\"\"`sqlalchemy` Asynchronous Engine\n\n    Example:\n        ```Python\n        async with self.engine.begin() as conn:\n            await conn.run_sync(SQLModel.metadata.create_all)\n        ```\n    \"\"\"\n    self.commit_on_exit: bool = commit_on_exit\n\"\"\"Whether to commit the session when the context manager or session generator exits.\"\"\"\n    session_options.setdefault(\"class_\", AsyncSession)\n    self.session_maker: Callable[..., AsyncSession] = sessionmaker(self.engine, **session_options)\n\"\"\"`sqlalchemy` session factory function\n\n    Example:\n        ```Python\n        async with self.session_maker() as sesson:\n            await session.delete(User,1)\n            await session.commit()\n        ```\n    \"\"\"\n    self._session_scope: ContextVar[Union[str, AsyncSession, None]] = ContextVar(\n        f\"_session_context_var_{id(self)}\", default=None\n    )\n    self.scoped_session: async_scoped_session = async_scoped_session(self.session_maker, scopefunc=self._session_scope.get)\n    super().__init__(engine)\n</code></pre>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.create","title":"<code>create(url, *, commit_on_exit=True, session_options=None, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize the client with a database connection string Args:     url: Asynchronous database connection string     commit_on_exit: Whether to commit the session when the context manager or session generator exits.     session_options: The default <code>session</code> initialization parameters     **kwargs: Asynchronous engine initialization parameters</p> <p>Returns:</p> Type Description <code>AsyncDatabase</code> <p>Return the client instance.</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>@classmethod\ndef create(\n    cls, url: Union[str, URL], *, commit_on_exit: bool = True, session_options: Mapping[str, Any] = None, **kwargs\n) -&gt; \"AsyncDatabase\":\n\"\"\"\n    Initialize the client with a database connection string\n    Args:\n        url: Asynchronous database connection string\n        commit_on_exit: Whether to commit the session when the context manager or session generator exits.\n        session_options: The default `session` initialization parameters\n        **kwargs: Asynchronous engine initialization parameters\n\n    Returns:\n        Return the client instance.\n    \"\"\"\n    kwargs.setdefault(\"future\", True)\n    engine = create_async_engine(url, **kwargs)\n    session_options = session_options or {}\n    return cls(engine, commit_on_exit=commit_on_exit, **session_options)\n</code></pre>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.run_sync","title":"<code>run_sync(fn, *args, is_session=True, **kwargs)</code>  <code>async</code>","text":"<p>Invoke the given sync callable passing sync self as the first argument.</p> <p>This method maintains the asyncio event loop all the way through to the database connection by running the given callable in a specially instrumented greenlet.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[[Concatenate[Union[Session, Connection], _P]], _T]</code> <p>Synchronization function</p> required <code>*args</code> <code>args</code> <p>Synchronization function positional argument</p> <code>()</code> <code>is_session</code> <code>bool</code> <p>Session or not. If true, an <code>AsyncSession</code> is created. If false, an <code>AsyncConnection</code> is created. The default is true.</p> <code>True</code> <code>**kwargs</code> <code>kwargs</code> <p>Synchronization function keyword argument</p> <code>{}</code> Example <pre><code>def get_user(session:Session,id:int):\n    return session.get(User,id)\n\nuser = await db.run_sync(get_user,5)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>async def run_sync(\n    self,\n    fn: Callable[[Concatenate[Union[Session, Connection], _P]], _T],\n    *args: _P.args,\n    is_session: bool = True,\n    **kwargs: _P.kwargs,\n) -&gt; Union[_T, _R]:\n\"\"\"\n    Invoke the given sync callable passing sync self as the first\n    argument.\n\n    This method maintains the asyncio event loop all the way through\n    to the database connection by running the given callable in a\n    specially instrumented greenlet.\n\n    Args:\n        fn: Synchronization function\n        *args: Synchronization function positional argument\n        is_session: Session or not. If true, an `AsyncSession` is created.\n            If false, an `AsyncConnection` is created. The default is true.\n        **kwargs: Synchronization function keyword argument\n\n    Returns: Returns the result of the fn synchronization function.\n\n    Example:\n        ```Python\n        def get_user(session:Session,id:int):\n            return session.get(User,id)\n\n        user = await db.run_sync(get_user,5)\n        ```\n    None:\n        The provided callable is invoked inline within the asyncio event\n        loop, and will block on traditional IO calls.  IO within this\n        callable should only call into SQLAlchemy's asyncio database\n        APIs which will be properly adapted to the greenlet context.\n    \"\"\"\n    if is_session:\n        return await self.session.run_sync(fn, *args, **kwargs)\n    async with self.engine.begin() as conn:\n        return await conn.run_sync(fn, *args, **kwargs)\n</code></pre>"},{"location":"Reference/AsyncDatabase/#sqlalchemy_database.database.AsyncDatabase.session_generator","title":"<code>session_generator()</code>  <code>async</code>","text":"<p>AsyncSession Generator, available for FastAPI dependencies.</p> Example <pre><code>@router.get('/get_user')\nasync get_user(id:int,session:AsyncSession=Depends(db.session_generator)):\n    return await session.get(User,id)\n</code></pre> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>async def session_generator(self) -&gt; AsyncGenerator[AsyncSession, Any]:\n\"\"\"AsyncSession Generator, available for FastAPI dependencies.\n\n    Example:\n        ```Python\n        @router.get('/get_user')\n        async get_user(id:int,session:AsyncSession=Depends(db.session_generator)):\n            return await session.get(User,id)\n        ```\n    \"\"\"\n    if self.scoped:\n\"\"\"If the current context has a session, return it.\"\"\"\n        yield self.session\n    else:\n\"\"\"If the current context has no session, create a new session.\"\"\"\n        async with self.session_maker() as session:\n            yield session\n            if self.commit_on_exit:\n                await session.commit()\n</code></pre>"},{"location":"Reference/Database/","title":"Database","text":"<p>             Bases: <code>AbcAsyncDatabase</code></p> <p><code>sqlalchemy</code> synchronous database client</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>class Database(AbcAsyncDatabase):\n\"\"\"`sqlalchemy` synchronous database client\"\"\"\n\n    def __init__(self, engine: Engine, commit_on_exit: bool = True, **session_options):\n        self.engine: Engine = engine\n        self.commit_on_exit: bool = commit_on_exit\n        session_options.setdefault(\"class_\", Session)\n        self.session_maker: Callable[..., Session] = sessionmaker(self.engine, **session_options)\n        self._session_scope: ContextVar[Union[str, Session, None]] = ContextVar(f\"_session_context_var_{id(self)}\", default=None)\n        self.scoped_session: scoped_session = scoped_session(self.session_maker, scopefunc=self._session_scope.get)\n\"\"\"Returns the Session local instance for the current context or current thread.\"\"\"\n        super().__init__(engine)\n\n    @property\n    def session(self) -&gt; Session:\n        return self.scoped_session()\n\n    @property\n    def scoped(self) -&gt; bool:\n        return bool(self._session_scope.get())\n\n    def __call__(self, scope: Any = None):\n        return SessionContextVarManager(self, scope=scope)\n\n    @classmethod\n    def create(\n        cls, url: Union[str, URL], *, commit_on_exit: bool = True, session_options: Optional[Mapping[str, Any]] = None, **kwargs\n    ) -&gt; \"Database\":\n        kwargs.setdefault(\"future\", True)\n        engine = create_engine(url, **kwargs)\n        session_options = session_options or {}\n        return cls(engine, **session_options)\n\n    def session_generator(self) -&gt; Generator[Session, Any, None]:\n        if self.scoped:\n\"\"\"If the current context has a session, return it.\"\"\"\n            yield self.session\n        else:\n\"\"\"If the current context has no session, create a new session.\"\"\"\n            with self.session_maker() as session:\n                yield session\n                if self.commit_on_exit:\n                    session.commit()\n\n    def run_sync(\n        self,\n        fn: Callable[[Concatenate[Union[Session, Connection], _P]], _T],\n        *args: _P.args,\n        is_session: bool = True,\n        **kwargs: _P.kwargs,\n    ) -&gt; Union[_T, _R]:\n        if is_session:\n            return fn(self.session, *args, **kwargs)\n        with self.engine.begin() as conn:\n            return fn(conn, *args, **kwargs)\n\n    def asyncify(self, db: Union[AsyncSession, AsyncDatabase], fn: Callable[_P, _T]) -&gt; Callable[_P, Awaitable[_T]]:\n\"\"\"Convert the given sync function that runs in the context of a sync session to\n        an async function that runs in the context of an async session.\n        Args:\n            db: Async database client or session\n            fn: sync function\n        Returns:\n            Returns the async function.\n        \"\"\"\n        session = db if isinstance(db, AsyncSession) else db.session\n\n        @functools.wraps(fn)\n        async def wrapper(*args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n            return await session.run_sync(self._sync_context_run, fn, *args, **kwargs)\n\n        return wrapper\n\n    def _sync_context_run(self, session: Session, fn: Callable[_P, _T], *args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n\"\"\"Run the given sync function in the context of the given sync session.\"\"\"\n        with self(session):\n            return fn(*args, **kwargs)\n</code></pre>"},{"location":"Reference/Database/#sqlalchemy_database.database.Database.scoped_session","title":"<code>scoped_session: scoped_session = scoped_session(self.session_maker, scopefunc=self._session_scope.get)</code>  <code>instance-attribute</code>","text":"<p>Returns the Session local instance for the current context or current thread.</p>"},{"location":"Reference/Database/#sqlalchemy_database.database.Database.asyncify","title":"<code>asyncify(db, fn)</code>","text":"<p>Convert the given sync function that runs in the context of a sync session to an async function that runs in the context of an async session. Args:     db: Async database client or session     fn: sync function Returns:     Returns the async function.</p> Source code in <code>/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/sqlalchemy_database/database.py</code> <pre><code>def asyncify(self, db: Union[AsyncSession, AsyncDatabase], fn: Callable[_P, _T]) -&gt; Callable[_P, Awaitable[_T]]:\n\"\"\"Convert the given sync function that runs in the context of a sync session to\n    an async function that runs in the context of an async session.\n    Args:\n        db: Async database client or session\n        fn: sync function\n    Returns:\n        Returns the async function.\n    \"\"\"\n    session = db if isinstance(db, AsyncSession) else db.session\n\n    @functools.wraps(fn)\n    async def wrapper(*args: _P.args, **kwargs: _P.kwargs) -&gt; _T:\n        return await session.run_sync(self._sync_context_run, fn, *args, **kwargs)\n\n    return wrapper\n</code></pre>"}]}